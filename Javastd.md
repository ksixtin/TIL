# Java Study	by LEO

1) 2주간 배운 내용 정리하기

**필수**

- 단순 폴더 이동

**추천**

* 핵심 개념(코드)들 마크다운으로 정리
* 기타 알고리즘 등 문제 풀었던 내용 마크다운으로 정리



혹시 정리를 다 한사람은 새롭게 폴더(test) 만들고 a.txt를 만들고 b.txt는 .gitignore 지정해놓고 원격저장소 올리기까지 반드시 실습.



### 1. 자바 개요

객체지향 언어로 개발되었으며 자바가상머신(JVM)을 사용하여 어느 운영체제에서나 같은 형태로 실행될 수 있다.

가전제품용 임베디드를 위한 언어로 썬마이크로시스템즈의 제임스 고슬링 팀에 의해 개발되었으며 1991년 오크라는 이름으로 시작해서 1996년 1.0.2버전부터 Java라는 이름으로 사용되었다.

1998년 발표된 J2SE 1.2에서 웹에서도 자바가 실행되게 해주는 자바애플릿이 추가되어 인기가 급상승됨.

특징으로 운영체제와 독립적으로 싱행가능, 불필요한 기능을 제거하여 쉽게 배울수 있고 자동 메모리 관리를 지원해서 타언어대비 안정성이 높으며 연산자 오버로딩을 금지하고 제네릭을 도입해 코드의 가독성을 높였다. 단점으로는 JVM을 거쳐야 하므로 타언어대비 실행속도가 느리며 개발자가 일일이 예외 처리를 해야하는 불편함이 있고 상대적으로 타 언어대비 작성해야 하는 코드의 길이가 긴편이다.

**객체지향(Object Orient T)의 기본 개념**

객객체지향의 개념은 크게 4가지가 있다.

1. 추상화(Abstraction) : 만들고자 하는 것들의 공통적인 것을 바탕으로 하나로 묶는 것

   (추가 보충 설명하기, 예시와 함께)

2. 캡슐화(Encapsulation) : 맡은 역할의 수행을 위해 최소한의 외부 접근만을 허용하는 것

   (추가 보충 설명하기, 예시와 함께)

3. 다형성(Polymorphism) : 자료형에 구애 받지 않고 프로그래밍 하는 것

   (추가 보충 설명하기, 예시와 함께)

4. 상속(Inheritance) : 하위 개념이 상위 개념의 속성 및 동작 등을 물려 받는 것

   (추가 보충 설명하기, 예시와 함께)

### 2. 자바의 기본구조

자바 프로그램은 한개 이상의 클래스로 구성되며 클래스는 변수와 메소드로 구성된다.

main ( ) 메소드 : 자바 프로그램이 실행되면 맨 먼저 main메소드를 찾아 그 안의 모든 명령문을 차례대로 실행한다.  따라서 하나의 자바 프로그램에는 main메소드를 가지는 클래스가 반드시 하나는 존재해야 하며  반드시 public static void로 선언되어야 한다.

명령문(statement) 자바의 동작을 명시하고 컴퓨터에 알려주는데 사용되는 문장을 명령문이라 하며 모든 명령문은 반드시 세미콜론(;)으로 끝나야 한다.



### 3. 기본 개념

#### 클래스(Class)

객체를 만들기 위한 설계도 또는 틀, 객체를 프로그램으로 만들기 위한 설계코드.

맴버로 속성을 표현하는 필드와 기능을 표현하는 메소드를 가진다. or

**크게 속성(변수)과 동작(함수)으로 구성되며 생성자도 포함된다.**

변수(객체의 정보, Field)와 함수(객체의 동작,Method), 생성자(Constructor)로 구성된다.

#### 변수(Variables)

데이터를 저장하기 위해 이름을 할당 받은 메모리 공간이며 공간에 저장된 값은 변경 될 수 있다.

**기본 규칙과 형태**

* 변수명은 영문자,숫자, 언더스코어’_’, 기호 $로만 구성 할 수 있고 숫자로 시작하거나 이름 사이에 공백을 포함 할 수 없다. 또한 자바에서 미리 정의된 키워드는 사용할 수 없다.
* 변수는 기본형(primitive) 8종(정수형-byte-short-int-long, 실수형-float-double, 문자형-char, 논리형-boolean)과 참조형(reference) 변수가 있다.
* 가장 많이쓰는 Boolean=1바이트, char=2바이트, int=4바이트, double=8바이트의 메모리를 사용한다.

**변수의 선언 :** 변수를 사용 하기전 반드시 변수를 선언하고 초기화 해야 하며 선언 방법은 2가지가 있다.

* 변수의 선언만 하는 것 : 먼저 변수를 선언해서 메모리를 할당받고 나중에 변수를 초기화한다, 
   선언된 변수는 반드시 초기화 후 사용해야 한다. 같은 타입은 동시에 여러 변수를 선언 가능.
* 변수의 선언과 동시에 초기화 : 아래 예제의 변수b 참조. 같은 타입은 동시에 선언과 초기화 가능.

~~~ 변수 형태
int a;					//a의 형태를 선언
int b = 20;				//b의 형태를 선언과 동시에 초기화
System.out.print(a);	//a가 초기화 되지 않았으므로 출력시 에러발생
System.out.print(b);	//a가 초기화되었으므로 사용해도 문제 없음
a = 10;					//변수 a의 초기화, 이후 사용가능
int c, d;				//같은 형태라면 복수로 변수 선언 가능
int e=30, f=50;			//같은 형태라면 복수로 변수 선언&초기화 가능

~~~

#### 함수(Method)

어떤 특정 작업을 수행하기 위한 명령문의 집합으로 객체의 동작(기능)을 정의한다.

클래스에서 메소드를 사용하는 이유는 중복되는 코드의 반복적인 프로그래밍을 피할 수 있고 모듈화로 인해 코드의 가독성도 좋아진다. 또한 프로그램에 문제가 발생하거나 기능 변경이 필요시 손쉽게 유지보수가 가능하다.

~~~ 함수 구조
기본 문법
접근제어자 반환타입 메소드이름(매개변수목록){	//선언부
	구현부
}

Public void setNumber(int n) {			//선언부
	if(n < 0)
		Number = 0;						//구현부
	else
    	Number = n;
}
~~~

**메소드 호출** : 메소드는 멤버 참조 연산자 도트(.)를 사용하여 호출 할 수 있다.

~~~ 메소드 호출방법
1. 매개변수가 없는 매소드의 호출 : 객체참조변수이름.메소드이름();
2. 매개변수가 있는 매소드의 호출 : 객체참조변수이름.메소드이름(인수1,인수2,..);

class Car {
	private int currentSpeed;
	private int accelerationTime;
	
	public void accelerate(int speed,int second){
		System.out.println(second+"초간 속도를 시속"+speed+"km로 가속함")
	}
}

public class Method01 {
	public static void main(String[] args){
	Car myCar = new Car();					//객체 생성
	myCar.accelerate(60, 3);				//메소드 호출
	}
}
실행 결과 : 3초간 속도를 시속 60km로 가속함
~~~







### 4. 





### 5. 배열

* 배열은 같은 타입의 변수들로 이루어진 유한 집합으로 정의
* 배열을 구성하는 각각의 값을 배열요소(element)라고 하며, 배열에서의 위치를 가리키는 숫자를 인덱스(index)라고 한다.
* 인덱스는 언제나 0부터 시작하며, 0을 포함한 양의 정수만을 가질 수 있다.

#### 1차원 배열(array)

~~~ 배열 기본 문법
문법 - 선언 (가능하면 1번 방식으로 사용할 것, 이유는 모름)
1. 타입[ ] 배열이름;	//int[] arry1;
2. 타입 배열이름[ ];	//int arry1[];
~~~

~~~ 배열생성
문법 - 생성
배열이름 = new 타입[배열길이]; //arry1 = new int[4];
~~~

~~~ 배열의 선언과 생성
동시에 선언과 생성하기 + 초기화
int[ ] arry1 = new int[3];	//길이가 3인 int형 배열의 선언 및 생성
int[ ] arry2 = new int[5];	//길이가 5인 int형 배열의 선언 및 생성
arry1[0]=85;
arry1[1]=65;
arry1[2]=90;

arry2[0]=85;

for(int i=0;i<arry1.length;i++) {
	System.out.print(arry1[i]+" ");
}
for(int i=0;i<arry2.length;i++) {
	System.out.print(arry2[i]+" ");
}
결괏값
85 65 90
85 0 0 0 0	//배열의 길이보다 적은 수의 배열 요소만을 초기화 할 경우, 나머지 배열 요소들은 배열의 타입에 맞게 자동으로 초기화 된다.
※ 타입에 따른 초깃값 = char '\u0000', byte&short&int 0, long 0L 등

~~~

~~~ 배열의 초기화
1. 타입[ ] 배열이름 = {배열요소1, 배열요소2, ..};
2. 타입[ ] 배열이름 = new 타입[ ] {배열요소1, 배열요소2, ..};

	// int[] arry1 = {10, 20, 30};
		int[] arry2 = new int[] {10, 20, 30, 40, 50};
		for(int i=0;i<arry2.length;i++) {
			System.out.print(arry2[i]+" ");
		}	
~~~

~~~ 배열 예제
배열 예제 : 배열 요소의 합과 평균을 구하라.
		int[] arry3 = new int[] {85, 65, 90};
		int sum = 0;
		for(int i=0;i<arry3.length;i++){
			sum += arry3[i];
		}
		System.out.println("총점은"+sum+"입니다");
		System.out.println("평균은"+sum/arry3.length+"입니다");
		}
		//총점은240입니다
		//평균은80입니다	
~~~

#### 2차원 배열(two dimensional array)

대괄호[ ]를 두번 사용하여 선언하며 첫번째 대괄호에는 세로크기, 두번째 대괄호에는 가로 크기를 지정한다. 즉 세로x가로로 표기한다

~~~ 2차원 배열
문법 - 선언 3가지 방법
1. 타입[][] 배열이름 ;
2. 타입 배열이름[][] ;
3. 타입[] 배열이름[] ;

문법 - 선언과 동시에 초기화
타입 배열이름[열의길이][행의길이]={
{배열요소[0][0],배열요소[0][1],...},
{배열요소[1][0],배열요소[1][1],...},
{배열요소[2][0],배열요소[2][1],...}
};

~~~

~~~ 2차원 배열 예제
2차원 배열 예제
int[][] arry4 = {
			{10, 20, 30, 40, 50},
			{50, 60, 70, 80, 90},
			{11, 12, 13, 14, 15}
			};
			for(int i=0;i<arry4.length;i++) {
				for(int j=0;j<arry4[i].length;j++) {
					System.out.print(arry4[i][j]+" ");
				}
				System.out.println();
			}
			//10 20 30 40 50 
			//50 60 70 80 90 
			//11 12 13 14 15 

~~~

#### 가변 배열(dynamic array)

길이를 명시하지 않고 행마다 다른 길이의 배열을 요소로 저장하는 배열

~~~가별배열 예제
		int[][] arry = {
				{10,20},
				{30,40,50,60},
				{100}
		};
		for(int i=0;i<arry.length;i++) {
			for(int j=0;j<arry[i].length;j++) {
				System.out.print(arry[i][j]+" ");
			}
			System.out.println();
		}
		//10 20 
		//30 40 50 60 
		//100 
~~~

#### 배열의 복사

배열은 한번 생성하면 그 길이를 변경할 수 없다 따라서 데이터를 추가하려면 더 큰 배열을 만들고 이전 배열의 데이터를 새로 만든 배열로 복사해야 한다.

배열의 복사 방법

* System클래스의 arrycopy() 메소드 : 가장 성능이 좋음.(복사하려는 배열을 기존의 빈객체 배열에 복사]
* Arrays클래스의 copyOf() 메소드 : 좀 더 유현항 방식으로 가장 많이 사용
* Object클래스의 clone()메소드
* for문과 인덱스를 이용한 복사

~~~ 배열복사 예제
		System.arraycopy()메소드 사용 예제
		int[]arr1 = new int[] {1,2,3,4,5};
		int newLen = 10;
		
		int[]arr2 = new int[newLen];
		System.arraycopy(arr1, 0, arr2, 0, arr1.length);
		//System.arraycopy(src, srcPos, dest, destPos, length);
		//src : 원본, scrPos : 원본의 어느부분부터 읽어올지 위치, dest : 복사하려는 대상, 
		//destPos : 받아온 자료를 어느 부분부터 쓸지 시작 위치, length : 원본에서 복사할 양
		for(int i=0;i<arr2.length;i++) {
			System.out.print(arr2[i]+" ");
		//결괏값 : 1 2 3 4 5 0 0 0 0 0 
		}
		
				int[] arrorg = {1,2,3,4,5,6};
		int[] cpy = new int[3];
		System.arraycopy(arrorg, 3, cpy, 0, 3);
			for(int d : cpy) {
		System.out.print(d+"\t");
			}
		//결괏값 : 4	5	6
~~~

#### Enhanced for 문

JDK 1.5부터 추가된 배열과 컬렉션의 모든 요소를 참조하기 위한 반복문.

~~~ 문법
for(타입 변수이름 : 배열이나 컬렉션 이름) {
배열의 길이만큼 반복 실행할 명령문;
}
int[] arry = new int[]{1,2,3,4,5};
for(int e : arry) {
	System.out.print(e + " ")
}
결괏값 : 1 2 3 4 5
~~~



